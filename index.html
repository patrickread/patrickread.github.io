<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Sudoku</title>
  <style>
    :root{
      --bg:#f1f5f9; --panel:#fff; --ink:#0f172a; --muted:#64748b; --accent:#4f46e5; --ok:#059669; --danger:#dc2626; --amber:#fde68a;
      --grid-gap:2px; --box-thick:3px; --radius:18px; --shadow:0 6px 20px rgba(2,8,23,.08);
    }
    *{box-sizing:border-box}
    body{margin:0;font:16px/1.4 system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:var(--bg);color:var(--ink);} 
    .wrap{min-height:100vh;display:grid;place-items:center;padding:24px}
    .app{width:min(1100px,100%);display:grid;grid-template-columns:1fr 320px;gap:24px}
    @media (max-width:900px){.app{grid-template-columns:1fr}}
    .card{background:var(--panel);border-radius:var(--radius);box-shadow:var(--shadow);padding:16px}
    h1{margin:0 0 8px;font-weight:700}
    .pills{display:flex;gap:8px;flex-wrap:wrap}
    .pill{background:#fff;border-radius:999px;padding:4px 10px;box-shadow:0 1px 3px rgba(2,8,23,.08)}/* Board */
.boardShell{padding:10px;background:#fff;border-radius:20px;box-shadow:var(--shadow)}
.board{display:grid;grid-template-columns:repeat(9,1fr);gap:var(--grid-gap);background:#cbd5e1;padding:var(--grid-gap);border-radius:14px}
.cell{position:relative;aspect-ratio:1/1;background:#fff;display:flex;align-items:center;justify-content:center;font-weight:600;font-size:22px;border-radius:6px;user-select:none;transition:background .12s, outline-color .12s, transform .03s}
.cell.given{color:#0f172a;font-weight:800}
.cell.input{color:#4338ca}
.cell.sel{background:#eef2ff;outline:2px solid #6366f1}
.cell.match{background:var(--amber)}
.cell.wrong{outline:2px solid var(--danger); color:var(--danger)}
.cell.conflict{background:#fecaca}

.notes{position:absolute;inset:0;display:grid;grid-template-columns:repeat(3,1fr);gap:1px;padding:2px;color:#94a3b8;font-size:10px}
.note{display:flex;align-items:center;justify-content:center}

.controls .btn{width:100%;padding:10px 12px;border-radius:12px;border:1px solid #e2e8f0;background:#f8fafc;cursor:pointer}
.controls .btn:hover{background:#eef2f7}
.btn.primary{background:var(--accent);color:#fff;border-color:transparent}
.kbd{padding:0 4px;border:1px solid #cbd5e1;border-radius:6px}

.row{display:flex;gap:8px;flex-wrap:wrap}
.grid5{display:grid;grid-template-columns:repeat(5,1fr);gap:8px}
.hide{display:none}

  </style>
</head>
<body>
<div class="wrap">
  <div class="app"><div class="left">
  <div class="card" style="display:flex;flex-direction:column;gap:12px;align-items:center">
    <h1>Sudoku</h1>
    <div class="pills">
      <span class="pill">Difficulty: <b id="difficultyLabel" style="text-transform:capitalize;margin-left:6px">medium</b></span>
      <span class="pill">‚è± <span id="timer">00:00</span></span>
      <span class="pill">‚ùå <span id="mistakes">0</span></span>
    </div>

    <div class="boardShell">
      <div id="board" class="board" aria-label="Sudoku board"></div>
    </div>

    <div class="grid5" style="max-width:420px;width:100%;margin-top:10px">
      <!-- numpad 1..9 + erase -->
    </div>
  </div>
</div>

<aside class="right">
  <div class="card">
    <div class="row" style="justify-content:space-between;align-items:center;margin-bottom:8px">
      <span class="label" style="font-weight:600">New Game</span>
      <select id="difficulty" style="padding:6px 8px;border:1px solid #cbd5e1;border-radius:8px">
        <option value="easy">Easy</option>
        <option value="medium" selected>Medium</option>
        <option value="hard">Hard</option>
      </select>
    </div>
    <div class="row" style="margin-top:6px">
      <button id="startBtn" class="btn primary">Start</button>
      <button data-new="easy" class="btn">Easy</button>
      <button data-new="medium" class="btn">Medium</button>
      <button data-new="hard" class="btn">Hard</button>
    </div>
  </div>

  <div class="card controls" style="margin-top:16px">
    <button id="notesToggle" class="btn">Notes Mode (Off) ‚ñß</button>
    <button id="autoNotes" class="btn">Auto Notes</button>
    <button id="check" class="btn">Check Progress</button>
    <button id="hint" class="btn">Hint</button>
    <button id="solve" class="btn">Solve Board</button>
  </div>

  <div class="card" style="margin-top:16px;color:var(--muted);font-size:14px">
    <p style="font-weight:700;margin:0 0 6px">Tips</p>
    <ul style="margin:0 0 0 18px;padding:0;display:grid;gap:4px">
      <li>Click a cell, then use 1‚Äì9 to fill. Use Erase (or Delete) to clear.</li>
      <li>Press <span class="kbd">N</span> to toggle notes mode.</li>
      <li>Arrow keys move selection. Hints fill one random empty cell.</li>
    </ul>
  </div>

  <div id="win" class="card hide" style="margin-top:16px;color:#065f46;background:#ecfdf5;border:1px solid #a7f3d0">
    üéâ Solved! Time: <span id="finalTime"></span> ‚Äî Mistakes: <span id="finalMistakes"></span>
  </div>
</aside>

  </div>
</div><script>
// ======================= Utilities =======================
const range = (n) => [...Array(n).keys()];
const clone = (grid) => grid.map(row => row.map(c => ({...c, notes:new Set(c.notes)})));
const emptyGrid = () => range(9).map(()=>range(9).map(()=>({value:0,given:false,notes:new Set(),conflict:false})));

function isSafe(vals,r,c,v){
  for(let i=0;i<9;i++){ if(vals[r][i]===v || vals[i][c]===v) return false; }
  const br=Math.floor(r/3)*3, bc=Math.floor(c/3)*3;
  for(let i=0;i<3;i++) for(let j=0;j<3;j++){ if(vals[br+i][bc+j]===v) return false; }
  return true;
}
function shuffled(a){ a=[...a]; for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]];} return a; }
function solve(vals){
  for(let r=0;r<9;r++) for(let c=0;c<9;c++) if(vals[r][c]===0){
    for(const v of shuffled([1,2,3,4,5,6,7,8,9])) if(isSafe(vals,r,c,v)){ vals[r][c]=v; if(solve(vals)) return true; vals[r][c]=0; }
    return false;
  }
  return true;
}
function countSolutions(vals,limit=2){ let count=0; (function bt(){
  for(let r=0;r<9;r++) for(let c=0;c<9;c++) if(vals[r][c]===0){
    for(let v=1;v<=9;v++) if(isSafe(vals,r,c,v)){ vals[r][c]=v; bt(); if(count>=limit) return; vals[r][c]=0; }
    return; }
  count++; })(); return Math.min(count,limit); }
function generateSolvedBoard(){ const v=range(9).map(()=>range(9).map(()=>0));
  const first=shuffled([1,2,3,4,5,6,7,8,9]); for(let c=0;c<9;c++) v[0][c]=first[c]; solve(v); return v; }
function makePuzzleFromSolution(solution,difficulty){
  const vals=solution.map(r=>r.slice()); const targets={easy:[40,45],medium:[32,36],hard:[26,30]};
  const [minCl,maxCl]=targets[difficulty]||targets.medium; const target=Math.floor((minCl+maxCl)/2);
  const order=shuffled(range(81)); let clues=81; for(const idx of order){ if(clues<=target) break; const r=Math.floor(idx/9), c=idx%9; const prev=vals[r][c]; if(prev===0) continue; vals[r][c]=0; const copy=vals.map(row=>row.slice()); const sol=countSolutions(copy,2); if(sol!==1) vals[r][c]=prev; else clues--; }
  return vals.map(row=>row.map(v=>({value:v,given:v!==0,notes:new Set(),conflict:false})));
}
function toValues(grid){ return grid.map(row=>row.map(c=>c.value||0)); }
function computeConflicts(grid){
  const vals=toValues(grid); const bad=new Set();
  for(let r=0;r<9;r++){ const seen=new Map(); for(let c=0;c<9;c++){ const v=vals[r][c]; if(!v) continue; const k=`r${r}#${v}`; if(seen.has(k)){ bad.add(`${r},${c}`); bad.add(`${r},${seen.get(k)}`); } else seen.set(k,c);} }
  for(let c=0;c<9;c++){ const seen=new Map(); for(let r=0;r<9;r++){ const v=vals[r][c]; if(!v) continue; const k=`c${c}#${v}`; if(seen.has(k)){ bad.add(`${r},${c}`); bad.add(`${seen.get(k)},${c}`);} else seen.set(k,r);} }
  for(let br=0;br<3;br++) for(let bc=0;bc<3;bc++){ const seen=new Map(); for(let i=0;i<3;i++) for(let j=0;j<3;j++){ const r=br*3+i, c=bc*3+j, v=vals[r][c]; if(!v) continue; const k=`b${br}${bc}#${v}`; if(seen.has(k)){ bad.add(`${r},${c}`); const p=seen.get(k); bad.add(`${p.r},${p.c}`);} else seen.set(k,{r,c}); }}
  return grid.map((row,r)=>row.map((cell,c)=>({...cell, conflict:bad.has(`${r},${c}`)})));
}
function findEmpty(grid){ for(let r=0;r<9;r++) for(let c=0;c<9;c++) if(grid[r][c].value===0) return {r,c}; return null; }
function solveFromGrid(grid){ const vals=toValues(grid); const s=vals.map(r=>r.slice()); return solve(s)?s:null; }

// ======================= State =======================
const state={
  difficulty:'medium', grid:emptyGrid(), solution:null, selected:{r:0,c:0}, notesMode:false, mistakes:0, seconds:0, timer:null, activeDigit:0,
};

// ======================= DOM helpers =======================
const elBoard = document.getElementById('board');
const elMistakes = document.getElementById('mistakes');
const elTimer = document.getElementById('timer');
const elDiff = document.getElementById('difficulty');
const elDiffLabel = document.getElementById('difficultyLabel');
const elWin = document.getElementById('win');
const elFinalTime = document.getElementById('finalTime');
const elFinalMistakes = document.getElementById('finalMistakes');
const padWrap = document.querySelector('.grid5');

function prettyTime(sec){ const m=String(Math.floor(sec/60)).padStart(2,'0'); const s=String(sec%60).padStart(2,'0'); return `${m}:${s}`; }

function startTimer(){ if(state.timer) clearInterval(state.timer); state.seconds=0; elTimer.textContent=prettyTime(0); state.timer=setInterval(()=>{ state.seconds++; elTimer.textContent=prettyTime(state.seconds); },1000); }

// ======================= Rendering =======================
function renderBoard(){
  elBoard.innerHTML='';
  for(let r=0;r<9;r++){
    for(let c=0;c<9;c++){
      const cell=state.grid[r][c];
      const d=document.createElement('div'); d.className='cell';
      if(cell.given) d.classList.add('given'); else d.classList.add('input');
      const isSel=state.selected.r===r && state.selected.c===c;
      if(isSel) d.classList.add('sel');
      const isWrong = !cell.given && cell.value!==0 && state.solution && cell.value !== state.solution[r][c];
      if(isWrong) d.classList.add('wrong');
      const sameAsSelected = state.activeDigit!==0 && cell.value===state.activeDigit;
      if(sameAsSelected && !isSel) d.classList.add('match');
      if(cell.conflict) d.classList.add('conflict');

      // borders for boxes
      const thickRight=((c+1)%3===0 && c!==8), thickBottom=((r+1)%3===0 && r!==8);
      if(thickRight) d.style.borderRight=`var(--box-thick) solid #cbd5e1`;
      if(thickBottom) d.style.borderBottom=`var(--box-thick) solid #cbd5e1`;

      d.tabIndex=0; d.setAttribute('role','button'); d.setAttribute('aria-label',`r${r+1} c${c+1}`);
      d.addEventListener('click',()=>{ state.selected={r,c}; state.activeDigit=state.grid[r][c].value||0; renderBoard(); });

      if(cell.value!==0){ d.textContent=cell.value; }
      else{
        const notes=document.createElement('div'); notes.className='notes';
        for(let n=1;n<=9;n++){ const s=document.createElement('div'); s.className='note'; s.textContent=cell.notes.has(n)?n:''; notes.appendChild(s);} 
        d.appendChild(notes);
      }
      elBoard.appendChild(d);
    }
  }
}

function renderPad(){
  padWrap.innerHTML='';
  for(let n=1;n<=9;n++){
    const b=document.createElement('button'); b.className='btn'; b.textContent=n;
    b.title = state.notesMode?`Toggle note ${n}`:`Place ${n}`;
    b.addEventListener('click',()=>handleInput(n));
    padWrap.appendChild(b);
  }
  const er=document.createElement('button'); er.className='btn'; er.textContent='Erase'; er.addEventListener('click',()=>handleInput(0));
  padWrap.appendChild(er);
}

function updateHeader(){
  elMistakes.textContent=state.mistakes;
  elDiffLabel.textContent=state.difficulty;
}

// ======================= Game logic wrappers =======================
function newGame(level=state.difficulty){
  state.difficulty=level; updateHeader();
  const solved=generateSolvedBoard();
  const puzzle=makePuzzleFromSolution(solved, level);
  state.solution=solved; state.grid=computeConflicts(puzzle);
  state.mistakes=0; state.selected={r:0,c:0}; state.activeDigit=0; startTimer(); renderBoard(); }

function handleInput(n){
  const {r,c}=state.selected; const g=clone(state.grid); const cell=g[r][c];
  if(cell.given) return;
  if(state.notesMode){ if(n===0) cell.notes.clear(); else if(cell.notes.has(n)) cell.notes.delete(n); else cell.notes.add(n); }
  else { cell.value=n; cell.notes.clear(); if(state.solution && n!==0 && n!==state.solution[r][c]) state.mistakes++; }
  state.grid=computeConflicts(g); state.activeDigit=state.grid[r][c].value||0; updateHeader(); renderBoard(); checkWin();
}

function giveHint(){ if(!state.solution) return; const empty=findEmpty(state.grid); if(!empty) return; const {r,c}=empty; const g=clone(state.grid); g[r][c].value=state.solution[r][c]; g[r][c].notes.clear(); state.grid=computeConflicts(g); renderBoard(); checkWin(); }

function autoNotes(){ const g=clone(state.grid); const vals=toValues(g); for(let r=0;r<9;r++) for(let c=0;c<9;c++){ const cell=g[r][c]; if(cell.value!==0){ cell.notes.clear(); continue;} const s=new Set(); for(let v=1;v<=9;v++) if(isSafe(vals,r,c,v)) s.add(v); cell.notes=s;} state.grid=computeConflicts(g); renderBoard(); }

function checkBoard(){ const wrong=[]; for(let r=0;r<9;r++) for(let c=0;c<9;c++){ const v=state.grid[r][c].value; if(v!==0 && v!==state.solution[r][c]) wrong.push({r,c}); }
  alert(wrong.length===0? 'Looking good so far! ‚úÖ' : `You have ${wrong.length} mistake(s) highlighted in red.`); }

function validateAndSolve(){ const solved=solveFromGrid(state.grid); if(!solved){ alert('This grid has no solution (based on current entries).\nTry undoing some moves.'); return; }
  const g=clone(state.grid); for(let r=0;r<9;r++) for(let c=0;c<9;c++){ g[r][c].value=solved[r][c]; g[r][c].notes.clear(); } state.grid=computeConflicts(g); renderBoard(); checkWin(); }

function checkWin(){ if(!state.solution) return; for(let r=0;r<9;r++) for(let c=0;c<9;c++) if(state.grid[r][c].value!==state.solution[r][c]) return; // not yet
  clearInterval(state.timer); elFinalTime.textContent=prettyTime(state.seconds); elFinalMistakes.textContent=state.mistakes; elWin.classList.remove('hide'); }

// ======================= Events =======================
renderPad();

document.getElementById('startBtn').addEventListener('click',()=>newGame(state.difficulty));
for(const b of document.querySelectorAll('[data-new]')) b.addEventListener('click', (e)=> newGame(e.target.getAttribute('data-new')));

document.getElementById('difficulty').addEventListener('change',(e)=>{ state.difficulty=e.target.value; elDiffLabel.textContent=state.difficulty; });

document.getElementById('notesToggle').addEventListener('click',()=>{ state.notesMode=!state.notesMode; document.getElementById('notesToggle').textContent = `Notes Mode (${state.notesMode?'On':'Off'}) ‚ñß`; });

document.getElementById('autoNotes').addEventListener('click',autoNotes);

document.getElementById('check').addEventListener('click',checkBoard);

document.getElementById('hint').addEventListener('click',giveHint);

document.getElementById('solve').addEventListener('click',validateAndSolve);

// keyboard
window.addEventListener('keydown',(e)=>{
  if(e.key>='1' && e.key<='9') handleInput(parseInt(e.key,10));
  if(['0','Backspace','Delete'].includes(e.key)) handleInput(0);
  if(e.key==='n' || e.key==='N'){ state.notesMode=!state.notesMode; document.getElementById('notesToggle').textContent = `Notes Mode (${state.notesMode?'On':'Off'}) ‚ñß`; }
  if(e.key==='ArrowUp'){ state.selected={r:(state.selected.r+8)%9,c:state.selected.c}; renderBoard(); }
  if(e.key==='ArrowDown'){ state.selected={r:(state.selected.r+1)%9,c:state.selected.c}; renderBoard(); }
  if(e.key==='ArrowLeft'){ state.selected={r:state.selected.r,c:(state.selected.c+8)%9}; renderBoard(); }
  if(e.key==='ArrowRight'){ state.selected={r:state.selected.r,c:(state.selected.c+1)%9}; renderBoard(); }
});

// boot
newGame('easy');
</script></body>
</html>