<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Sudoku</title>
  <style>
    :root{
      --bg:#f1f5f9; --panel:#fff; --ink:#0f172a; --muted:#64748b; --accent:#4f46e5; --ok:#059669; --danger:#dc2626; --amber:#fde68a;
      --grid-gap:2px; --box-thick:3px; --radius:18px; --shadow:0 6px 20px rgba(2,8,23,.08);
    }
    *{box-sizing:border-box}
    body{margin:0;font:16px/1.4 system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:var(--bg);color:var(--ink);}
    .wrap{min-height:100vh;display:grid;place-items:center;padding:24px}
    .app{width:min(1100px,100%);display:grid;grid-template-columns:1fr 320px;gap:24px}
    @media (max-width:900px){.app{grid-template-columns:1fr}}
    .card{background:var(--panel);border-radius:var(--radius);box-shadow:var(--shadow);padding:16px}
    h1{margin:0 0 8px;font-weight:700}
    .pills{display:flex;gap:8px;flex-wrap:wrap}
    .pill{background:#fff;border-radius:999px;padding:4px 10px;box-shadow:0 1px 3px rgba(2,8,23,.08)}
    .pill button{all:unset;cursor:pointer}

    /* Hamburger & Drawer */
    .hamburger{position:fixed;top:12px;left:12px;z-index:40;background:#fff;border:none;border-radius:12px;padding:10px 12px;box-shadow:var(--shadow);cursor:pointer}
    .hamburger .bar{display:block;width:26px;height:3px;background:#334155;margin:4px 0;border-radius:2px}
    .drawer{position:fixed;top:0;left:0;height:100%;width:290px;background:#fff;box-shadow:0 20px 60px rgba(2,8,23,.26);transform:translateX(-100%);transition:transform .22s ease;z-index:35;display:flex;flex-direction:column}
    .drawer.open{transform:translateX(0)}
    .drawer .head{display:flex;align-items:center;justify-content:space-between;padding:14px 16px;border-bottom:1px solid #e5e7eb;font-weight:700}
    .drawer .body{padding:14px 16px;display:grid;gap:10px}
    .backdrop{position:fixed;inset:0;background:rgba(15,23,42,.35);backdrop-filter:blur(1px);z-index:30;display:none}
    .backdrop.show{display:block}

    /* Board */
    .boardShell{padding:10px;background:#fff;border-radius:20px;box-shadow:var(--shadow)}
    .board{display:grid;grid-template-columns:repeat(9,1fr);gap:var(--grid-gap);background:#cbd5e1;padding:var(--grid-gap);border-radius:14px}
    .cell{position:relative;aspect-ratio:1/1;background:#fff;display:flex;align-items:center;justify-content:center;font-weight:600;font-size:22px;border-radius:6px;user-select:none;transition:background .12s, outline-color .12s, transform .03s}
    .cell.given{color:#0f172a;font-weight:800}
    .cell.input{color:#4338ca}
    .cell.sel{background:#eef2ff;outline:2px solid #6366f1}
    .cell.match{background:var(--amber)}
    .cell.wrong{outline:2px solid var(--danger); color:var(--danger)}
    .cell.conflict{background:#fecaca}

    .notes{position:absolute;inset:0;display:grid;grid-template-columns:repeat(3,1fr);gap:1px;padding:2px;color:#94a3b8;font-size:10px}
    .note{display:flex;align-items:center;justify-content:center}

    .controls .btn{width:100%;padding:12px 14px;border-radius:12px;border:1px solid #e2e8f0;background:#f8fafc;cursor:pointer}
    .controls .btn:hover{background:#eef2f7}
    .btn.primary{background:var(--accent);color:#fff;border-color:transparent}
    .kbd{padding:0 4px;border:1px solid #cbd5e1;border-radius:6px}

    .row{display:flex;gap:8px;flex-wrap:wrap}

    /* Numpad ‚Äì bigger, square touch targets */
    .pad{display:grid;grid-template-columns:repeat(5,1fr);gap:10px}
    .btn.num{aspect-ratio:1/1;height:64px;border-radius:16px;font-size:20px}

    .hide{display:none}

    /* Confetti canvas */
    #confetti{position:fixed;inset:0;pointer-events:none;z-index:60;display:none}
    #confetti.show{display:block}

    /* Pause overlay */
    #pauseOverlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(15,23,42,.6);color:#fff;z-index:65;font-size:28px;font-weight:800;text-align:center;padding:24px;}
    #pauseOverlay.show{display:flex}
    #pauseOverlay small{display:block;font-weight:600;opacity:.9;margin-top:8px}
    #pauseOverlay .pauseModal {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
    }
    #pauseOverlay .pauseIcon {
      font-size: 48px;
      line-height: 1;
    }
    #pauseOverlay:active .pauseIcon {
      transform: scale(.96);
    }

  </style>
</head>
<body>

<!-- Confetti canvas -->
<canvas id="confetti"></canvas>
<!-- Pause overlay -->
<!-- Pause overlay -->
<div id="pauseOverlay" role="button" aria-label="Resume (tap)">
  <div class="pauseModal">
    <div class="pauseIcon" aria-hidden="true">‚è∏Ô∏è</div>
    <div class="pauseText">Paused</div>
    <small>Tap to resume</small>
  </div>
</div>

<button id="hamburger" class="hamburger" aria-label="Toggle menu">
  <span class="bar"></span>
  <span class="bar"></span>
  <span class="bar"></span>
</button>
<div id="backdrop" class="backdrop"></div>

<!-- Slide-out drawer with New Game -->
<aside id="drawer" class="drawer" aria-label="New game menu">
  <div class="head">
    <span>New Game</span>
    <button id="closeDrawer" class="btn" style="padding:6px 10px;border-radius:8px;border:1px solid #e5e7eb;background:#f8fafc">Close</button>
  </div>
  <div class="body">
    <label class="label" style="font-size:14px;color:var(--muted)">Difficulty</label>
    <select id="difficulty" style="padding:8px;border:1px solid #cbd5e1;border-radius:10px">
      <option value="easy">Easy</option>
      <option value="medium" selected>Medium</option>
      <option value="hard">Hard</option>
    </select>
    <div class="row">
      <button id="startBtn" class="btn primary">Start</button>
      <button data-new="easy" class="btn">Easy</button>
      <button data-new="medium" class="btn">Medium</button>
      <button data-new="hard" class="btn">Hard</button>
    </div>
  </div>
</aside>

<div class="wrap">
  <div class="app">

    <div class="left">
      <div class="card" style="display:flex;flex-direction:column;gap:12px;align-items:center">
        <h1>Sudoku</h1>
        <div class="pills">
          <span class="pill">Difficulty: <b id="difficultyLabel" style="text-transform:capitalize;margin-left:6px">medium</b></span>
          <!-- Timer pill toggles pause -->
          <span id="timerPill" class="pill" style="cursor:pointer" title="Tap to pause/resume">‚è± <span id="timer">00:00</span></span>
          <span class="pill">‚ùå <span id="mistakes">0</span></span>
        </div>

        <div id="boardShell" class="boardShell">
          <div id="board" class="board" aria-label="Sudoku board"></div>
        </div>

        <div class="pad" style="max-width:420px;width:100%;margin-top:10px">
          <!-- numpad 1..9 + erase -->
        </div>
      </div>
    </div>

    <aside class="right">
      <div class="card controls">
        <button id="notesToggle" class="btn">Notes Mode (Off) ‚ñß</button>
        <button id="autoNotes" class="btn">Auto Notes</button>
        <button id="check" class="btn">Check Progress</button>
        <button id="hint" class="btn">Hint</button>
        <button id="solve" class="btn">Solve Board</button>
      </div>

      <div class="card" style="margin-top:16px;color:var(--muted);font-size:14px">
        <p style="font-weight:700;margin:0 0 6px">Tips</p>
        <ul style="margin:0 0 0 18px;padding:0;display:grid;gap:4px">
          <li>Click a cell, then use 1‚Äì9 to fill. Use Erase (or Delete) to clear.</li>
          <li>Press <span class="kbd">N</span> to toggle notes mode.</li>
          <li>Arrow keys move selection. Hints fill one random empty cell.</li>
        </ul>
      </div>

      <div id="win" class="card hide" style="margin-top:16px;color:#065f46;background:#ecfdf5;border:1px solid #a7f3d0">
        üéâ Solved! Time: <span id="finalTime"></span> ‚Äî Mistakes: <span id="finalMistakes"></span>
      </div>
    </aside>

  </div>
</div>

<script>
// ======================= Utilities =======================
const range = (n) => [...Array(n).keys()];
const clone = (grid) => grid.map(row => row.map(c => ({...c, notes:new Set(c.notes)})));
const emptyGrid = () => range(9).map(()=>range(9).map(()=>({value:0,given:false,notes:new Set(),conflict:false})));

function isSafe(vals,r,c,v){
  for(let i=0;i<9;i++){ if(vals[r][i]===v || vals[i][c]===v) return false; }
  const br=Math.floor(r/3)*3, bc=Math.floor(c/3)*3;
  for(let i=0;i<3;i++) for(let j=0;j<3;j++){ if(vals[br+i][bc+j]===v) return false; }
  return true;
}
function shuffled(a){ a=[...a]; for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]];} return a; }
function solve(vals){
  for(let r=0;r<9;r++) for(let c=0;c<9;c++) if(vals[r][c]===0){
    for(const v of shuffled([1,2,3,4,5,6,7,8,9])) if(isSafe(vals,r,c,v)){ vals[r][c]=v; if(solve(vals)) return true; vals[r][c]=0; }
    return false;
  }
  return true;
}
function countSolutions(vals,limit=2){ let count=0; (function bt(){
  for(let r=0;r<9;r++) for(let c=0;c<9;c++) if(vals[r][c]===0){
    for(let v=1;v<=9;v++) if(isSafe(vals,r,c,v)){ vals[r][c]=v; bt(); if(count>=limit) return; vals[r][c]=0; }
    return; }
  count++; })(); return Math.min(count,limit); }
function generateSolvedBoard(){ const v=range(9).map(()=>range(9).map(()=>0));
  const first=shuffled([1,2,3,4,5,6,7,8,9]); for(let c=0;c<9;c++) v[0][c]=first[c]; solve(v); return v; }
function makePuzzleFromSolution(solution,difficulty){
  const vals=solution.map(r=>r.slice()); const targets={easy:[40,45],medium:[32,36],hard:[26,30]};
  const [minCl,maxCl]=targets[difficulty]||targets.medium; const target=Math.floor((minCl+maxCl)/2);
  const order=shuffled(range(81)); let clues=81; for(const idx of order){ if(clues<=target) break; const r=Math.floor(idx/9), c=idx%9; const prev=vals[r][c]; if(prev===0) continue; vals[r][c]=0; const copy=vals.map(row=>row.slice()); const sol=countSolutions(copy,2); if(sol!==1) vals[r][c]=prev; else clues--; }
  return vals.map(row=>row.map(v=>({value:v,given:v!==0,notes:new Set(),conflict:false})));
}
function toValues(grid){ return grid.map(row=>row.map(c=>c.value||0)); }
function computeConflicts(grid){
  const vals=toValues(grid); const bad=new Set();
  for(let r=0;r<9;r++){ const seen=new Map(); for(let c=0;c<9;c++){ const v=vals[r][c]; if(!v) continue; const k=`r${r}#${v}`; if(seen.has(k)){ bad.add(`${r},${c}`); bad.add(`${r},${seen.get(k)}`); } else seen.set(k,c);} }
  for(let c=0;c<9;c++){ const seen=new Map(); for(let r=0;r<9;r++){ const v=vals[r][c]; if(!v) continue; const k=`c${c}#${v}`; if(seen.has(k)){ bad.add(`${r},${c}`); bad.add(`${seen.get(k)},${c}`);} else seen.set(k,r);} }
  for(let br=0;br<3;br++) for(let bc=0;bc<3;bc++){ const seen=new Map(); for(let i=0;i<3;i++) for(let j=0;j<3;j++){ const r=br*3+i, c=bc*3+j, v=vals[r][c]; if(!v) continue; const k=`b${br}${bc}#${v}`; if(seen.has(k)){ bad.add(`${r},${c}`); const p=seen.get(k); bad.add(`${p.r},${p.c}`);} else seen.set(k,{r,c}); }}
  return grid.map((row,r)=>row.map((cell,c)=>({...cell, conflict:bad.has(`${r},${c}`)})));
}
function findEmpty(grid){ for(let r=0;r<9;r++) for(let c=0;c<9;c++) if(grid[r][c].value===0) return {r,c}; return null; }
function solveFromGrid(grid){ const vals=toValues(grid); const s=vals.map(r=>r.slice()); return solve(s)?s:null; }

// ======================= State =======================
const state={
  paused:false,
  difficulty:'medium', grid:emptyGrid(), solution:null, selected:{r:0,c:0}, notesMode:false, mistakes:0, seconds:0, timer:null, activeDigit:0,
};

// ======================= DOM helpers =======================
const elBoard = document.getElementById('board');
const elBoardShell = document.getElementById('boardShell');
const elMistakes = document.getElementById('mistakes');
const elTimer = document.getElementById('timer');
const elTimerPill = document.getElementById('timerPill');
const elDiff = document.getElementById('difficulty');
const elDiffLabel = document.getElementById('difficultyLabel');
const elWin = document.getElementById('win');
const elFinalTime = document.getElementById('finalTime');
const elFinalMistakes = document.getElementById('finalMistakes');
const padWrap = document.querySelector('.pad');

const drawer = document.getElementById('drawer');
const backdrop = document.getElementById('backdrop');
const hamburger = document.getElementById('hamburger');
const closeDrawer = document.getElementById('closeDrawer');

const confettiCanvas = document.getElementById('confetti');
const cctx = confettiCanvas.getContext('2d');
const pauseOverlay = document.getElementById('pauseOverlay');

function prettyTime(sec){ const m=String(Math.floor(sec/60)).padStart(2,'0'); const s=String(sec%60).padStart(2,'0'); return `${m}:${s}`; }

function startTimer(){
  if(state.timer) clearInterval(state.timer);
  if(state.paused) return; // don't tick when paused
  elTimer.textContent=prettyTime(state.seconds);
  state.timer=setInterval(()=>{ state.seconds++; elTimer.textContent=prettyTime(state.seconds); },1000);
}

// ======================= Confetti =======================
function launchConfetti(duration=2500){
  const W = confettiCanvas.width = window.innerWidth;
  const H = confettiCanvas.height = window.innerHeight;
  const colors = ['#f59e0b','#10b981','#3b82f6','#ef4444','#a855f7','#f97316'];
  const N = 180;
  const parts = Array.from({length:N},()=>({
    x: Math.random()*W,
    y: -Math.random()*H,
    vx: (Math.random()-0.5)*2,
    vy: 2 + Math.random()*3,
    size: 4 + Math.random()*6,
    rot: Math.random()*Math.PI*2,
    vr: (Math.random()-0.5)*0.2,
    color: colors[(Math.random()*colors.length)|0]
  }));
  let raf, start;
  confettiCanvas.classList.add('show');
  function step(t){
    if(!start) start=t; const dt=t-start; cctx.clearRect(0,0,W,H);
    parts.forEach(p=>{ p.x+=p.vx; p.y+=p.vy; p.rot+=p.vr; if(p.y>H){p.y=-10; p.x=Math.random()*W;} cctx.save(); cctx.translate(p.x,p.y); cctx.rotate(p.rot); cctx.fillStyle=p.color; cctx.fillRect(-p.size/2,-p.size/2,p.size,p.size); cctx.restore(); });
    if(dt < duration) raf=requestAnimationFrame(step); else { confettiCanvas.classList.remove('show'); cancelAnimationFrame(raf); }
  }
  raf=requestAnimationFrame(step);
}

// ======================= Rendering =======================
function renderBoard(){
  elBoard.innerHTML='';
  for(let r=0;r<9;r++){
    for(let c=0;c<9;c++){
      const cell=state.grid[r][c];
      const d=document.createElement('div'); d.className='cell';
      if(cell.given) d.classList.add('given'); else d.classList.add('input');
      const isSel=state.selected.r===r && state.selected.c===c;
      if(isSel) d.classList.add('sel');
      const isWrong = !cell.given && cell.value!==0 && state.solution && cell.value !== state.solution[r][c];
      if(isWrong) d.classList.add('wrong');
      const sameAsSelected = state.activeDigit!==0 && cell.value===state.activeDigit;
      if(sameAsSelected && !isSel) d.classList.add('match');
      if(cell.conflict) d.classList.add('conflict');

      // borders for boxes
      const thickRight=((c+1)%3===0 && c!==8), thickBottom=((r+1)%3===0 && r!==8);
      if(thickRight) d.style.borderRight=`var(--box-thick) solid #cbd5e1`;
      if(thickBottom) d.style.borderBottom=`var(--box-thick) solid #cbd5e1`;

      d.tabIndex=0; d.setAttribute('role','button'); d.setAttribute('aria-label',`r${r+1} c${c+1}`);
      d.addEventListener('click',()=>{ if(state.paused) return; state.selected={r,c}; state.activeDigit=state.grid[r][c].value||0; renderBoard(); });

      if(cell.value!==0){ d.textContent=cell.value; }
      else{
        const notes=document.createElement('div'); notes.className='notes';
        for(let n=1;n<=9;n++){ const s=document.createElement('div'); s.className='note'; s.textContent=cell.notes.has(n)?n:''; notes.appendChild(s);}
        d.appendChild(notes);
      }
      elBoard.appendChild(d);
    }
  }
}

function renderPad(){
  padWrap.innerHTML='';
  for(let n=1;n<=9;n++){
    const b=document.createElement('button'); b.className='btn num'; b.textContent=n;
    b.title = state.notesMode?`Toggle note ${n}`:`Place ${n}`;
    b.addEventListener('click',()=>handleInput(n));
    padWrap.appendChild(b);
  }
  const er=document.createElement('button'); er.className='btn num'; er.textContent='Erase'; er.addEventListener('click',()=>handleInput(0));
  padWrap.appendChild(er);
}

function updateHeader(){
  elMistakes.textContent=state.mistakes;
  elDiffLabel.textContent=state.difficulty;
}

// ======================= Game logic wrappers =======================
function newGame(level=state.difficulty){
  state.difficulty=level; updateHeader();
  const solved=generateSolvedBoard();
  const puzzle=makePuzzleFromSolution(solved, level);
  state.solution=solved; state.grid=computeConflicts(puzzle);
  state.mistakes=0; state.selected={r:0,c:0}; state.activeDigit=0;
  state.paused=false; pauseOverlay.classList.remove('show'); elBoardShell.classList.remove('hide'); padWrap.classList.remove('hide');
  clearInterval(state.timer); state.seconds=0; startTimer(); renderBoard(); elWin.classList.add('hide');
}

function handleInput(n){ if(state.paused) return;
  const {r,c}=state.selected; const g=clone(state.grid); const cell=g[r][c];
  if(cell.given) return;
  if(state.notesMode){ if(n===0) cell.notes.clear(); else if(cell.notes.has(n)) cell.notes.delete(n); else cell.notes.add(n); }
  else { cell.value=n; cell.notes.clear(); if(state.solution && n!==0 && n!==state.solution[r][c]) state.mistakes++; }
  state.grid=computeConflicts(g); state.activeDigit=state.grid[r][c].value||0; updateHeader(); renderBoard(); checkWin();
}

function giveHint(){ if(state.paused) return; if(!state.solution) return; const empty=findEmpty(state.grid); if(!empty) return; const {r,c}=empty; const g=clone(state.grid); g[r][c].value=state.solution[r][c]; g[r][c].notes.clear(); state.grid=computeConflicts(g); renderBoard(); checkWin(); }

function autoNotes(){ if(state.paused) return; const g=clone(state.grid); const vals=toValues(g); for(let r=0;r<9;r++) for(let c=0;c<9;c++){ const cell=g[r][c]; if(cell.value!==0){ cell.notes.clear(); continue;} const s=new Set(); for(let v=1;v<=9;v++) if(isSafe(vals,r,c,v)) s.add(v); cell.notes=s;} state.grid=computeConflicts(g); renderBoard(); }

function checkBoard(){ if(state.paused) return; const wrong=[]; for(let r=0;r<9;r++) for(let c=0;c<9;c++){ const v=state.grid[r][c].value; if(v!==0 && v!==state.solution[r][c]) wrong.push({r,c}); }
  alert(wrong.length===0? 'Looking good so far! ‚úÖ' : `You have ${wrong.length} mistake(s) highlighted in red.`); }

function validateAndSolve(){ if(state.paused) return; const solved=solveFromGrid(state.grid); if(!solved){ alert('This grid has no solution (based on current entries).\nTry undoing some moves.'); return; }
  const g=clone(state.grid); for(let r=0;r<9;r++) for(let c=0;c<9;c++){ g[r][c].value=solved[r][c]; g[r][c].notes.clear(); } state.grid=computeConflicts(g); renderBoard(); checkWin(); }

function checkWin(){ if(!state.solution) return; for(let r=0;r<9;r++) for(let c=0;c<9;c++) if(state.grid[r][c].value!==state.solution[r][c]) return; // not yet
  clearInterval(state.timer); elFinalTime.textContent=prettyTime(state.seconds); elFinalMistakes.textContent=state.mistakes; elWin.classList.remove('hide');
  launchConfetti();
}

// ======================= Events =======================
renderPad();

document.getElementById('startBtn').addEventListener('click',()=>{ newGame(state.difficulty); closeDrawer.click(); });
for(const b of document.querySelectorAll('[data-new]')) b.addEventListener('click', (e)=> { newGame(e.target.getAttribute('data-new')); closeDrawer.click(); });

document.getElementById('difficulty').addEventListener('change',(e)=>{ state.difficulty=e.target.value; elDiffLabel.textContent=state.difficulty; });

document.getElementById('notesToggle').addEventListener('click',()=>{ state.notesMode=!state.notesMode; document.getElementById('notesToggle').textContent = `Notes Mode (${state.notesMode?'On':'Off'}) ‚ñß`; });

document.getElementById('autoNotes').addEventListener('click',autoNotes);

document.getElementById('check').addEventListener('click',checkBoard);

document.getElementById('hint').addEventListener('click',giveHint);

document.getElementById('solve').addEventListener('click',validateAndSolve);

// keyboard
window.addEventListener('keydown',(e)=>{
  if(e.key>='1' && e.key<='9') handleInput(parseInt(e.key,10));
  if(['0','Backspace','Delete'].includes(e.key)) handleInput(0);
  if(e.key==='n' || e.key==='N'){ state.notesMode=!state.notesMode; document.getElementById('notesToggle').textContent = `Notes Mode (${state.notesMode?'On':'Off'}) ‚ñß`; }
  if(e.key==='ArrowUp'){ state.selected={r:(state.selected.r+8)%9,c:state.selected.c}; renderBoard(); }
  if(e.key==='ArrowDown'){ state.selected={r:(state.selected.r+1)%9,c:state.selected.c}; renderBoard(); }
  if(e.key==='ArrowLeft'){ state.selected={r:state.selected.r,c:(state.selected.c+8)%9}; renderBoard(); }
  if(e.key==='ArrowRight'){ state.selected={r:state.selected.r,c:(state.selected.c+1)%9}; renderBoard(); }
});

// Drawer
function openDrawer(){ drawer.classList.add('open'); backdrop.classList.add('show'); }
function closeDrawerFn(){ drawer.classList.remove('open'); backdrop.classList.remove('show'); }
hamburger.addEventListener('click', openDrawer);
backdrop.addEventListener('click', closeDrawerFn);
closeDrawer.addEventListener('click', closeDrawerFn);

// Pause toggle via timer pill
function pauseGame(){ if(state.paused) return; state.paused=true; clearInterval(state.timer); pauseOverlay.classList.add('show'); elBoardShell.classList.add('hide'); padWrap.classList.add('hide'); }
function resumeGame(){ if(!state.paused) return; state.paused=false; pauseOverlay.classList.remove('show'); elBoardShell.classList.remove('hide'); padWrap.classList.remove('hide'); startTimer(); }
function togglePause(){ state.paused ? resumeGame() : pauseGame(); }
elTimerPill.addEventListener('click', togglePause);
pauseOverlay.addEventListener('click', resumeGame);


// boot
newGame('easy');
</script>
</body>
</html>
