import React, { useEffect, useMemo, useRef, useState } from "react";

// --------------------------- Utilities ---------------------------
const range = (n) => [...Array(n).keys()];
const clone = (grid) => grid.map((row) => row.map((c) => ({ ...c, notes: new Set(c.notes) })));
const emptyGrid = () =>
  range(9).map(() =>
    range(9).map(() => ({ value: 0, given: false, notes: new Set(), conflict: false }))
  );

// Check if placing value at r,c is valid for current numeric grid
function isSafe(gridVals, r, c, v) {
  for (let i = 0; i < 9; i++) {
    if (gridVals[r][i] === v || gridVals[i][c] === v) return false;
  }
  const br = Math.floor(r / 3) * 3;
  const bc = Math.floor(c / 3) * 3;
  for (let i = 0; i < 3; i++) {
    for (let j = 0; j < 3; j++) {
      if (gridVals[br + i][bc + j] === v) return false;
    }
  }
  return true;
}

function shuffled(nums) {
  const a = [...nums];
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

// Backtracking solver that fills grid in-place, returns boolean
function solve(gridVals) {
  for (let r = 0; r < 9; r++) {
    for (let c = 0; c < 9; c++) {
      if (gridVals[r][c] === 0) {
        for (const v of shuffled([1, 2, 3, 4, 5, 6, 7, 8, 9])) {
          if (isSafe(gridVals, r, c, v)) {
            gridVals[r][c] = v;
            if (solve(gridVals)) return true;
            gridVals[r][c] = 0;
          }
        }
        return false; // no value works
      }
    }
  }
  return true; // solved
}

// Count number of solutions up to 2 (for uniqueness check). Returns 0,1,2.
function countSolutions(gridVals, limit = 2) {
  let count = 0;
  function backtrack() {
    for (let r = 0; r < 9; r++) {
      for (let c = 0; c < 9; c++) {
        if (gridVals[r][c] === 0) {
          for (let v = 1; v <= 9; v++) {
            if (isSafe(gridVals, r, c, v)) {
              gridVals[r][c] = v;
              backtrack();
              if (count >= limit) return; // early stop
              gridVals[r][c] = 0;
            }
          }
          return; // no value fits
        }
      }
    }
    count++;
  }
  backtrack();
  return Math.min(count, limit);
}

// Generate a fully solved valid Sudoku board
function generateSolvedBoard() {
  const gridVals = range(9).map(() => range(9).map(() => 0));

  // Seed first row with shuffled 1..9 for variety
  const firstRow = shuffled([1, 2, 3, 4, 5, 6, 7, 8, 9]);
  for (let c = 0; c < 9; c++) gridVals[0][c] = firstRow[c];

  solve(gridVals);
  return gridVals;
}

// Create a puzzle by removing cells while ensuring unique solution.
function makePuzzleFromSolution(solutionVals, difficulty) {
  const gridVals = solutionVals.map((row) => row.slice());

  // Target clues per difficulty
  const targets = {
    easy: [40, 45],
    medium: [32, 36],
    hard: [26, 30],
  };
  const [minClues, maxClues] = targets[difficulty] || targets.medium;
  const target = Math.floor((minClues + maxClues) / 2);

  // Order of cell indices to try removing (shuffled)
  const order = shuffled(range(81));
  let removed = 0;
  let clues = 81;
  for (const idx of order) {
    if (clues <= target) break;
    const r = Math.floor(idx / 9);
    const c = idx % 9;
    const prev = gridVals[r][c];
    if (prev === 0) continue;

    gridVals[r][c] = 0;
    const copy = gridVals.map((row) => row.slice());
    const solutions = countSolutions(copy, 2);
    if (solutions !== 1) {
      // revert to keep uniqueness
      gridVals[r][c] = prev;
    } else {
      removed++;
      clues--;
    }
  }

  // Convert to cell objects
  const puzzle = gridVals.map((row, r) =>
    row.map((v, c) => ({ value: v, given: v !== 0, notes: new Set(), conflict: false }))
  );
  // Fill given values from solution where zero in puzzle should remain empty but keep track of solution separately
  return puzzle;
}

function toValues(grid) {
  return grid.map((row) => row.map((c) => c.value || 0));
}

function computeConflicts(grid) {
  const vals = toValues(grid);
  const conflicts = new Set(); // keys as "r,c"

  // rows
  for (let r = 0; r < 9; r++) {
    const seen = new Map();
    for (let c = 0; c < 9; c++) {
      const v = vals[r][c];
      if (v === 0) continue;
      const key = `r${r}#${v}`;
      if (seen.has(key)) {
        conflicts.add(`${r},${c}`);
        conflicts.add(`${r},${seen.get(key)}`);
      } else seen.set(key, c);
    }
  }
  // cols
  for (let c = 0; c < 9; c++) {
    const seen = new Map();
    for (let r = 0; r < 9; r++) {
      const v = vals[r][c];
      if (v === 0) continue;
      const key = `c${c}#${v}`;
      if (seen.has(key)) {
        conflicts.add(`${r},${c}`);
        conflicts.add(`${seen.get(key)},${c}`);
      } else seen.set(key, r);
    }
  }
  // boxes
  for (let br = 0; br < 3; br++) {
    for (let bc = 0; bc < 3; bc++) {
      const seen = new Map();
      for (let i = 0; i < 3; i++) {
        for (let j = 0; j < 3; j++) {
          const r = br * 3 + i;
          const c = bc * 3 + j;
          const v = vals[r][c];
          if (v === 0) continue;
          const key = `b${br}${bc}#${v}`;
          if (seen.has(key)) {
            conflicts.add(`${r},${c}`);
            const prev = seen.get(key);
            conflicts.add(`${prev.r},${prev.c}`);
          } else seen.set(key, { r, c });
        }
      }
    }
  }

  return grid.map((row, r) =>
    row.map((cell, c) => ({ ...cell, conflict: conflicts.has(`${r},${c}`) }))
  );
}

function findEmpty(grid) {
  for (let r = 0; r < 9; r++) {
    for (let c = 0; c < 9; c++) {
      if (grid[r][c].value === 0) return { r, c };
    }
  }
  return null;
}

function solveFromGrid(grid) {
  const vals = toValues(grid);
  const solved = vals.map((row) => row.slice());
  const ok = solve(solved);
  return ok ? solved : null;
}

// --------------------------- React UI ---------------------------
function Confetti({show,duration=3000}){
  const ref=useRef(null);
  useEffect(()=>{
    if(!show) return; const canvas=ref.current; if(!canvas) return; const ctx=canvas.getContext('2d');
    let w=canvas.width=window.innerWidth, h=canvas.height=window.innerHeight; const onResize=()=>{w=canvas.width=window.innerWidth; h=canvas.height=window.innerHeight;};
    window.addEventListener('resize',onResize);
    const colors=['#f59e0b','#10b981','#3b82f6','#ef4444','#a855f7','#f97316'];
    const N=160; const parts=[...Array(N)].map(()=>({
      x:Math.random()*w,y:-10*Math.random()*h,vx:(Math.random()-0.5)*2,vy:2+Math.random()*3,
      size:4+Math.random()*4,rot:Math.random()*Math.PI*2,vr:(Math.random()-0.5)*0.2,color:colors[(Math.random()*colors.length)|0]
    }));
    let raf; const start=performance.now();
    const loop=(t)=>{ const dt=16/1000; ctx.clearRect(0,0,w,h);
      parts.forEach(p=>{ p.x+=p.vx; p.y+=p.vy; p.rot+=p.vr; if(p.y>h){p.y=-10; p.x=Math.random()*w;} ctx.save(); ctx.translate(p.x,p.y); ctx.rotate(p.rot); ctx.fillStyle=p.color; ctx.fillRect(-p.size/2,-p.size/2,p.size,p.size); ctx.restore(); });
      if(t-start<duration) raf=requestAnimationFrame(loop); };
    raf=requestAnimationFrame(loop);
    return ()=>{cancelAnimationFrame(raf); window.removeEventListener('resize',onResize);};
  },[show,duration]);
  return <canvas ref={ref} className={"pointer-events-none fixed inset-0 z-50 "+(show?"":"hidden")} />
}

export default function SudokuApp() {
  const [difficulty, setDifficulty] = useState("medium");
  const [grid, setGrid] = useState(emptyGrid());
  const [solution, setSolution] = useState(null); // 9x9 numbers
  const [selected, setSelected] = useState({ r: 0, c: 0 });
  const [notesMode, setNotesMode] = useState(false);
  const [mistakes, setMistakes] = useState(0);
  const [seconds, setSeconds] = useState(0);
  const timerRef = useRef(null);
  const [navOpen,setNavOpen]=useState(false);
  const [showConfetti,setShowConfetti]=useState(false);
  const [activeDigit, setActiveDigit] = useState(0);
  useEffect(() => {
    const r = selected?.r ?? 0;
    const c = selected?.c ?? 0;
    const v = (grid?.[r]?.[c]?.value) || 0;
    setActiveDigit(v);
  }, [selected, grid]);

  // value of the currently selected cell (for same-number highlighting)
  const selectedValue = useMemo(() => {
    const r = selected?.r ?? 0;
    const c = selected?.c ?? 0;
    try { return grid?.[r]?.[c]?.value || 0; } catch { return 0; }
  }, [grid, selected]);

  const isComplete = useMemo(() => {
    if (!solution) return false;
    for (let r = 0; r < 9; r++) {
      for (let c = 0; c < 9; c++) {
        if (grid[r][c].value !== solution[r][c]) return false;
      }
    }
    return true;
  }, [grid, solution]);

  // fire confetti when completed
  useEffect(()=>{ if(isComplete){ setShowConfetti(true); const t=setTimeout(()=>setShowConfetti(false), 3000); return ()=>clearTimeout(t);} },[isComplete]);

  function newGame(level = difficulty) {
    // Generate fresh solution and puzzle
    const solved = generateSolvedBoard();
    const puzzle = makePuzzleFromSolution(solved, level);

    // Save solution separately
    setSolution(solved);
    setGrid(computeConflicts(puzzle));
    setDifficulty(level);
    setMistakes(0);
    setSeconds(0);
    if (timerRef.current) clearInterval(timerRef.current);
    timerRef.current = setInterval(() => setSeconds((s) => s + 1), 1000);
  }

  useEffect(() => {
    newGame("easy");
    return () => timerRef.current && clearInterval(timerRef.current);
  }, []);

  function handleInput(n) {
    setGrid((prev) => {
      const g = clone(prev);
      const { r, c } = selected;
      const cell = g[r][c];
      if (cell.given) return prev; // immutable
      if (notesMode) {
        if (n === 0) {
          cell.notes.clear();
        } else if (cell.notes.has(n)) cell.notes.delete(n);
        else cell.notes.add(n);
      } else {
        cell.value = n;
        cell.notes.clear();
        if (solution && n !== 0 && n !== solution[r][c]) {
          setMistakes((m) => m + 1);
        }
      }
      return computeConflicts(g);
    });
  }

  function eraseCell() {
    handleInput(0);
  }

  function giveHint() {
    if (!solution) return;
    const empty = findEmpty(grid);
    if (!empty) return;
    const { r, c } = empty;
    setGrid((prev) => {
      const g = clone(prev);
      g[r][c].value = solution[r][c];
      g[r][c].notes.clear();
      return computeConflicts(g);
    });
  }

  function autoNotes() {
    setGrid((prev) => {
      const g = clone(prev);
      const vals = toValues(g);
      for (let r = 0; r < 9; r++) {
        for (let c = 0; c < 9; c++) {
          const cell = g[r][c];
          if (cell.value !== 0) {
            cell.notes.clear();
            continue;
          }
          const s = new Set();
          for (let v = 1; v <= 9; v++) if (isSafe(vals, r, c, v)) s.add(v);
          cell.notes = s;
        }
      }
      return computeConflicts(g);
    });
  }

  function checkBoard() {
    if (!solution) return;
    const wrong = [];
    for (let r = 0; r < 9; r++) {
      for (let c = 0; c < 9; c++) {
        const v = grid[r][c].value;
        if (v !== 0 && v !== solution[r][c]) wrong.push({ r, c });
      }
    }
    if (wrong.length === 0) alert("Looking good so far! ✅");
    else alert(`You have ${wrong.length} mistake(s) highlighted in red.`);
  }

  function validateAndSolve() {
    const solved = solveFromGrid(grid);
    if (!solved) {
      alert("This grid has no solution (based on current entries).\nTry undoing some moves.");
      return;
    }
    setGrid((prev) => {
      const g = clone(prev);
      for (let r = 0; r < 9; r++) for (let c = 0; c < 9; c++) {
        g[r][c].value = solved[r][c];
        g[r][c].notes.clear();
      }
      return computeConflicts(g);
    });
  }

  const prettyTime = useMemo(() => {
    const m = Math.floor(seconds / 60).toString().padStart(2, "0");
    const s = (seconds % 60).toString().padStart(2, "0");
    return `${m}:${s}`;
  }, [seconds]);

  // Keyboard controls
  useEffect(() => {
    function onKey(e) {
      if (e.key >= "1" && e.key <= "9") handleInput(parseInt(e.key, 10));
      if (e.key === "0" || e.key === "Backspace" || e.key === "Delete") handleInput(0);
      if (e.key === "n" || e.key === "N") setNotesMode((m) => !m);
      if (e.key === "ArrowUp") setSelected((s) => ({ r: (s.r + 8) % 9, c: s.c }));
      if (e.key === "ArrowDown") setSelected((s) => ({ r: (s.r + 1) % 9, c: s.c }));
      if (e.key === "ArrowLeft") setSelected((s) => ({ r: s.r, c: (s.c + 8) % 9 }));
      if (e.key === "ArrowRight") setSelected((s) => ({ r: s.r, c: (s.c + 1) % 9 }));
    }
    window.addEventListener("keydown", onKey);
    return () => window.removeEventListener("keydown", onKey);
  }, [selected, notesMode, grid, solution]);

  // --------------------------- Render ---------------------------
  return (
    <div className="min-h-screen w-full flex items-center justify-center bg-slate-100 p-6">
      <Confetti show={showConfetti} />
      {/* Hamburger */}
      <button onClick={()=>setNavOpen(v=>!v)} className="fixed top-4 left-4 z-40 bg-white shadow rounded-xl px-3 py-2 active:scale-[0.98] md:hidden">
        <span className="block w-6 h-0.5 bg-slate-700 mb-1"></span>
        <span className="block w-6 h-0.5 bg-slate-700 mb-1"></span>
        <span className="block w-6 h-0.5 bg-slate-700"></span>
      </button>

      {/* Slide-out New Game menu */}
      <div className={["fixed z-30 top-0 left-0 h-full w-72 bg-white shadow-xl transition-transform", navOpen?"translate-x-0":"-translate-x-full"].join(" ")}>
        <div className="p-4 border-b flex items-center justify-between">
          <span className="font-semibold">New Game</span>
          <button onClick={()=>setNavOpen(false)} className="px-2 py-1 rounded-md bg-slate-100">Close</button>
        </div>
        <div className="p-4 space-y-3">
          <label className="text-sm text-slate-600">Difficulty</label>
          <select className="w-full px-2 py-2 border rounded-md" value={difficulty} onChange={(e)=>setDifficulty(e.target.value)}>
            <option value="easy">Easy</option>
            <option value="medium">Medium</option>
            <option value="hard">Hard</option>
          </select>
          <div className="grid grid-cols-2 gap-2">
            <button onClick={()=>newGame(difficulty)} className="px-3 py-3 rounded-xl bg-indigo-600 text-white hover:bg-indigo-700">Start</button>
            <button onClick={()=>newGame('easy')} className="px-3 py-3 rounded-xl bg-slate-100 hover:bg-slate-200">Easy</button>
            <button onClick={()=>newGame('medium')} className="px-3 py-3 rounded-xl bg-slate-100 hover:bg-slate-200">Medium</button>
            <button onClick={()=>newGame('hard')} className="px-3 py-3 rounded-xl bg-slate-100 hover:bg-slate-200">Hard</button>
          </div>
        </div>
      </div>
      <div className="w-full max-w-5xl grid md:grid-cols-[1fr_320px] gap-6">
        {/* Left: Board */}
        <div className="flex flex-col items-center gap-4">
          <div className="w-full flex items-center justify-between">
            <h1 className="text-2xl md:text-3xl font-semibold tracking-tight">Sudoku</h1>
            {/* Desktop toggle for menu */}
            <button onClick={()=>setNavOpen(v=>!v)} className="hidden md:inline-flex items-center gap-2 bg-white shadow px-3 py-2 rounded-xl">
              <span className="w-5 h-0.5 bg-slate-700 relative before:content-[''] before:block before:w-5 before:h-0.5 before:bg-slate-700 before:translate-y-[-6px] after:content-[''] after:block after:w-5 after:h-0.5 after:bg-slate-700 after:translate-y-[6px]"></span>
              Menu
            </button>
          </div>
          <div className="flex items-center gap-3 text-sm">
            <span className="px-2 py-1 rounded-full bg-white shadow">Difficulty: <b className="capitalize">{difficulty}</b></span>
            <span className="px-2 py-1 rounded-full bg-white shadow">⏱ {prettyTime}</span>
            <span className="px-2 py-1 rounded-full bg-white shadow">❌ {mistakes}</span>
          </div>

          {/* Sudoku Grid */}
          <div className="bg-white p-2 rounded-2xl shadow-lg">
            <div className="grid grid-cols-9 gap-[2px] bg-slate-300 p-[2px] rounded-xl">
              {range(9).map((r) =>
                range(9).map((c) => {
                  const cell = grid[r][c];
                  const isSel = selected.r === r && selected.c === c;
                  const isWrong = !cell.given && cell.value !== 0 && solution && cell.value !== solution[r][c];
                  const sameAsSelected = activeDigit !== 0 && cell.value === activeDigit;
                  const thickRight = (c + 1) % 3 === 0 && c !== 8;
                  const thickBottom = (r + 1) % 3 === 0 && r !== 8;
                  return (
                    <div
                      key={`${r}-${c}`}
                      onClick={() => setSelected({ r, c })}
                      className={[
                        "relative aspect-square select-none flex items-center justify-center",
                        "text-xl md:text-2xl font-medium",
                        "transition-colors",
                        isSel ? "bg-indigo-50 outline outline-2 outline-indigo-400" : "",
                        sameAsSelected && !isSel ? "bg-amber-200" : "bg-white",
                        isWrong ? "ring-2 ring-red-400" : "",
                        cell.given ? "text-slate-800" : "text-indigo-700",
                        cell.conflict ? "bg-red-100" : "",
                      ].join(" ")}
                      style={{
                        borderRight: thickRight ? "3px solid rgb(203,213,225)" : undefined,
                        borderBottom: thickBottom ? "3px solid rgb(203,213,225)" : undefined,
                      }}
                    >
                      {cell.value !== 0 ? (
                        <span className={(cell.given ? "font-bold" : "font-semibold") + ( !cell.given && solution && cell.value !== solution[r][c] ? " text-red-600" : "")}>{cell.value}</span>
                      ) : (
                        <div className="grid grid-cols-3 gap-0.5 p-0.5 w-full h-full">
                          {range(9).map((n) => (
                            <div key={n} className="text-[10px] md:text-[12px] leading-none text-slate-400 flex items-center justify-center">
                              {cell.notes.has(n + 1) ? n + 1 : ""}
                            </div>
                          ))}
                        </div>
                      )}
                    </div>
                  );
                })
              )}
            </div>
          </div>

          {/* Numpad */}
          <div className="grid grid-cols-5 gap-3 w-full max-w-md">
            {[1, 2, 3, 4, 5, 6, 7, 8, 9].map((n) => (
              <button
                key={n}
                onClick={() => handleInput(n)}
                className="aspect-square min-w-14 min-h-14 rounded-2xl bg-white shadow hover:shadow-md active:scale-[0.98] text-lg"
                title={notesMode ? `Toggle note ${n}` : `Place ${n}`}
              >
                {n}
              </button>
            ))}
            <button onClick={eraseCell} className="aspect-square min-w-14 min-h-14 rounded-2xl bg-white shadow hover:shadow-md text-base">Erase</button>
          </div>
        </div>

        {/* Right: Controls */}
        <aside className="space-y-4">
          <div className="bg-white p-4 rounded-2xl shadow">
            <div className="flex items-center justify-between">
              <span className="font-semibold">New Game</span>
              <select
                className="px-2 py-1 border rounded-md"
                value={difficulty}
                onChange={(e) => setDifficulty(e.target.value)}
              >
                <option value="easy">Easy</option>
                <option value="medium">Medium</option>
                <option value="hard">Hard</option>
              </select>
            </div>
            <div className="mt-3 grid grid-cols-2 gap-2">
              <button onClick={() => newGame(difficulty)} className="px-3 py-2 rounded-xl bg-indigo-600 text-white hover:bg-indigo-700">Start</button>
              <button onClick={() => newGame("easy")} className="px-3 py-2 rounded-xl bg-slate-100 hover:bg-slate-200">Easy</button>
              <button onClick={() => newGame("medium")} className="px-3 py-2 rounded-xl bg-slate-100 hover:bg-slate-200">Medium</button>
              <button onClick={() => newGame("hard")} className="px-3 py-2 rounded-xl bg-slate-100 hover:bg-slate-200">Hard</button>
            </div>
          </div>

          <div className="bg-white p-4 rounded-2xl shadow space-y-2">
            <button onClick={() => setNotesMode((m) => !m)} className={"w-full px-3 py-2 rounded-xl border " + (notesMode ? "bg-indigo-50 border-indigo-300" : "bg-slate-50 hover:bg-slate-100")}>Notes Mode {notesMode ? "(On)" : "(Off)"} ▧</button>
            <button onClick={autoNotes} className="w-full px-3 py-2 rounded-xl bg-slate-50 hover:bg-slate-100 border">Auto Notes</button>
            <button onClick={checkBoard} className="w-full px-3 py-2 rounded-xl bg-slate-50 hover:bg-slate-100 border">Check Progress</button>
            <button onClick={giveHint} className="w-full px-3 py-2 rounded-xl bg-slate-50 hover:bg-slate-100 border">Hint</button>
            <button onClick={validateAndSolve} className="w-full px-3 py-2 rounded-xl bg-slate-50 hover:bg-slate-100 border">Solve Board</button>
          </div>

          <div className="bg-white p-4 rounded-2xl shadow text-sm text-slate-600">
            <p className="font-semibold mb-1">Tips</p>
            <ul className="list-disc pl-5 space-y-1">
              <li>Click a cell, then use 1–9 to fill. Use Erase (or Delete) to clear.</li>
              <li>Press <kbd className="px-1 border rounded">N</kbd> to toggle notes mode.</li>
              <li>Arrow keys move selection. Hints fill one random empty cell.</li>
            </ul>
          </div>

          {isComplete && (
            <div className="bg-emerald-50 border border-emerald-200 p-4 rounded-2xl text-emerald-700">
              🎉 Solved! Time: {prettyTime} — Mistakes: {mistakes}
            </div>
          )}
        </aside>
      </div>
    </div>
  );
}
