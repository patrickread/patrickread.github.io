<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Sudoku</title>
  <style>
    :root{
      --bg:#f1f5f9; --panel:#fff; --ink:#0f172a; --muted:#64748b; --accent:#4f46e5; --ok:#059669; --danger:#dc2626; --amber:#fde68a;
      --grid-gap:2px; --box-thick:3px; --radius:18px; --shadow:0 6px 20px rgba(2,8,23,.08);
    }
    [data-theme="dark"]{
      --bg:#0f172a; --panel:#1e293b; --ink:#f1f5f9; --muted:#94a3b8; --accent:#6366f1; --ok:#10b981; --danger:#ef4444; --amber:#fbbf24;
      --shadow:0 6px 20px rgba(0,0,0,.3);
    }
    *{box-sizing:border-box}
    body{margin:0;font:16px/1.4 system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:var(--bg);color:var(--ink);}
    html,body{max-width:100%;overflow-x:hidden}
    .wrap{min-height:100vh;display:grid;place-items:center;padding:24px}
    .app{width:min(1100px,100%);display:grid;grid-template-columns:1fr 320px;gap:24px;max-width:100%}
    @media (max-width:900px){.app{grid-template-columns:1fr}}
    .card{background:var(--panel);border-radius:var(--radius);box-shadow:var(--shadow);padding:16px}
    h1{margin:0 0 8px;font-weight:700}
    .pills{display:flex;gap:8px;flex-wrap:wrap}
    .pill{background:var(--panel);border-radius:999px;padding:4px 10px;box-shadow:0 1px 3px rgba(2,8,23,.08)}
    .pill.button{cursor:pointer}

    /* Board */
    .boardShell{padding:10px;background:var(--panel);border-radius:20px;box-shadow:var(--shadow);max-width:100%;width:100%;overflow:hidden}
    .board{display:grid;grid-template-columns:repeat(9,1fr);gap:var(--grid-gap);background:#cbd5e1;padding:var(--grid-gap);border-radius:14px;max-width:100%;width:100%}
    .cell{position:relative;aspect-ratio:1/1;background:var(--panel);display:flex;align-items:center;justify-content:center;font-weight:600;font-size:22px;border-radius:6px;user-select:none;transition:background .12s, outline-color .12s, transform .03s}
    .cell.given{color:var(--ink);font-weight:800}
    .cell.input{color:var(--accent)}
    .cell.sel{background:#eef2ff;outline:2px solid var(--accent);outline-offset:-2px}
    [data-theme="dark"] .cell.sel{background:#334155}
    .cell.match{background:var(--amber)}
    .cell.wrong{outline:2px solid var(--danger); color:var(--danger);outline-offset:-2px}
    .cell.conflict{background:#fecaca}
    [data-theme="dark"] .cell.conflict{background:#7f1d1d}

    .notes{position:absolute;inset:0;display:grid;grid-template-columns:repeat(3,1fr);gap:0px;padding:0px;margin-top:-2px;color:var(--muted);font-size:10px}
    .note{display:flex;align-items:center;justify-content:center}

    .controls .btn{width:100%;padding:12px 14px;border-radius:12px;border:1px solid #e2e8f0;background:#f8fafc;cursor:pointer;color:var(--ink)}
    .controls .btn:hover{background:#eef2f7}
    [data-theme="dark"] .controls .btn{border-color:#374151;background:#374151}
    [data-theme="dark"] .controls .btn:hover{background:#4b5563}
    .btn.primary{background:var(--accent);color:#fff;border-color:transparent}
    .kbd{padding:0 4px;border:1px solid #cbd5e1;border-radius:6px;background:var(--panel)}

    .row{display:flex;gap:8px;flex-wrap:wrap}

    /* Numpad ‚Äì bigger, square touch targets with remaining counts */
    .pad{display:grid;grid-template-columns:repeat(5,1fr);gap:10px}
    .btn.num{aspect-ratio:1/1;height:72px;border-radius:16px;font-size:20px;display:flex;flex-direction:column;align-items:center;justify-content:center;gap:4px;background:var(--panel);border:1px solid #e2e8f0;color:var(--ink)}
    [data-theme="dark"] .btn.num{border-color:#374151}
    .btn.num .sub{font-size:12px;color:var(--muted);line-height:1}
    .btn.num:disabled{opacity:.45;cursor:not-allowed;filter:saturate(.2)}

    .hide{display:none}

    /* Confetti canvas */
    #confetti{position:fixed;inset:0;pointer-events:none;z-index:60;display:none}
    #confetti.show{display:block}

    /* Pause overlay */
    #pauseOverlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(15,23,42,.6);color:#fff;z-index:65;font-size:28px;font-weight:800;text-align:center;padding:24px;}
    #pauseOverlay.show{display:flex}
    #pauseOverlay .pauseModal{display:flex;flex-direction:column;align-items:center;gap:8px}
    #pauseOverlay .pauseIcon{font-size:48px;line-height:1}
    #pauseOverlay:active .pauseIcon{transform:scale(.96)}
    #pauseOverlay small{display:block;font-weight:600;opacity:.9;margin-top:8px}

    /* New Game modal */
    #ngBackdrop{position:fixed;inset:0;background:rgba(15,23,42,.35);backdrop-filter:blur(1px);z-index:70;display:none}
    #ngBackdrop.show{display:block}
    #ngModal{position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:75}
    #ngModal.show{display:flex}
    .modalCard{width:min(420px,92vw);background:var(--panel);border-radius:16px;box-shadow:0 20px 60px rgba(2,8,23,.25);overflow:hidden}
    .modalHead{display:flex;justify-content:space-between;align-items:center;padding:12px 14px;border-bottom:1px solid #e5e7eb;font-weight:700;color:var(--ink)}
    .modalBody{padding:14px;display:grid;gap:12px}
    .xbtn{border:none;background:#f1f5f9;border-radius:8px;padding:6px 10px;cursor:pointer;color:var(--ink)}
    [data-theme="dark"] .xbtn{background:#374151}
    .modalActions{display:flex;gap:8px;justify-content:flex-end}
    .select{padding:8px;border:1px solid #cbd5e1;border-radius:10px;background:var(--panel);color:var(--ink)}

    /* High Scores modal */
    #hsBackdrop{position:fixed;inset:0;background:rgba(15,23,42,.35);backdrop-filter:blur(1px);z-index:70;display:none}
    #hsBackdrop.show{display:block}
    #hsModal{position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:75}
    #hsModal.show{display:flex}

    /* Dark mode toggle */
    .theme-toggle{
      position:fixed;top:16px;right:16px;z-index:80;
      width:48px;height:48px;border-radius:50%;
      background:var(--panel);border:1px solid #e2e8f0;
      display:flex;align-items:center;justify-content:center;
      cursor:pointer;font-size:20px;color:var(--ink);
      box-shadow:var(--shadow);transition:all .2s;
    }
    .theme-toggle:hover{transform:scale(1.05)}
    [data-theme="dark"] .theme-toggle{border-color:#374151}

    /* Mobile optimizations to avoid horizontal scroll */
    @media (max-width:600px){
      .wrap{padding:12px}
      .left .card,.right .card{width:100%}
      .left .card{align-items:stretch !important}
      .cell{font-size:24px}
      .btn.num{height:64px}
      .pills{gap:6px}
      .pad{max-width:480px !important}
      .theme-toggle{top:12px;right:12px;width:44px;height:44px;font-size:18px}
    }
  </style>
</head>
<body>

<!-- Dark mode toggle -->
<button id="themeToggle" class="theme-toggle" aria-label="Toggle dark mode" title="Toggle dark mode">
  <span id="themeIcon">üåô</span>
</button>

<!-- Confetti canvas -->
<canvas id="confetti"></canvas>
<!-- Pause overlay (tap to resume) -->
<div id="pauseOverlay" role="button" aria-label="Resume (tap)">
  <div class="pauseModal">
    <div class="pauseIcon" aria-hidden="true">‚è∏Ô∏è</div>
    <div class="pauseText">Paused</div>
    <small>Tap to resume</small>
  </div>
</div>

<div class="wrap">
  <div class="app">

    <div class="left">
      <div class="card" style="display:flex;flex-direction:column;gap:12px;align-items:center">
        <h1>Sudoku</h1>
        <div class="pills">
          <!-- Difficulty pill (tap to open New Game modal) -->
          <span id="difficultyPill" class="pill button" title="Start a new game">Difficulty: <b id="difficultyLabel" style="text-transform:capitalize;margin-left:6px">medium</b></span>
          <!-- Timer (tap to pause/resume) -->
          <span id="timerPill" class="pill button" title="Tap to pause/resume">‚è± <span id="timer">00:00</span></span>
          <span class="pill">‚ùå <span id="mistakes">0</span></span>
          <span id="bestPillBtn" class="pill button" title="View high scores">üèÜ <span id="bestPill">‚Äî</span></span>
        </div>

        <div id="boardShell" class="boardShell">
          <div id="board" class="board" aria-label="Sudoku board"></div>
        </div>

        <div class="pad" style="max-width:420px;width:100%;margin-top:10px">
          <!-- numpad 1..9 + erase (rendered by JS) -->
        </div>
      </div>
    </div>

    <aside class="right">
      <div class="card controls">
        <button id="notesToggle" class="btn">Notes Mode (Off) ‚ñß</button>
        <!-- removed Check Progress -->
        <button id="hint" class="btn">Hint</button>
        <button id="solve" class="btn">Solve Board</button>
      </div>

      <div class="card" style="margin-top:16px;color:var(--muted);font-size:14px">
        <p style="font-weight:700;margin:0 0 6px">Tips</p>
        <ul style="margin:0 0 0 18px;padding:0;display:grid;gap:4px">
          <li>Click a cell, then use 1‚Äì9 to fill. Use Erase (or Delete) to clear.</li>
          <li>Press <span class="kbd">N</span> to toggle notes mode.</li>
          <li>Arrow keys move selection. Hints fill one random empty cell.</li>
        </ul>
      </div>

      <div id="win" class="card hide" style="margin-top:16px;color:#065f46;background:#ecfdf5;border:1px solid #a7f3d0">
        üéâ Solved! Time: <span id="finalTime"></span> ‚Äî Mistakes: <span id="finalMistakes"></span> ‚Äî Best: <span id="bestTime"></span>
      </div>
    </aside>

  </div>
</div>

<!-- New Game modal -->
<div id="ngBackdrop"></div>
<div id="ngModal" role="dialog" aria-modal="true" aria-labelledby="ngTitle">
  <div class="modalCard">
    <div class="modalHead">
      <span id="ngTitle">Start a new game?</span>
      <button id="ngClose" class="xbtn" aria-label="Close">‚úï</button>
    </div>
    <div class="modalBody">
      <label for="ngDifficulty" style="font-size:14px;color:var(--muted)">Select difficulty</label>
      <select id="ngDifficulty" class="select">
        <option value="easy">easy</option>
        <option value="medium" selected>medium</option>
        <option value="hard">hard</option>
      </select>
      <div class="modalActions">
        <button id="ngCancel" class="btn">Cancel</button>
        <button id="ngStart" class="btn primary">Start new game</button>
      </div>
    </div>
  </div>
</div>

<!-- High Scores modal -->
<div id="hsBackdrop"></div>
<div id="hsModal" role="dialog" aria-modal="true" aria-labelledby="hsTitle">
  <div class="modalCard">
    <div class="modalHead">
      <span id="hsTitle">High Scores</span>
      <button id="hsClose" class="xbtn" aria-label="Close">‚úï</button>
    </div>
    <div class="modalBody">
      <div class="row" style="justify-content:space-between"><div>Easy</div><div id="hsEasy">‚Äî</div></div>
      <div class="row" style="justify-content:space-between"><div>Medium</div><div id="hsMedium">‚Äî</div></div>
      <div class="row" style="justify-content:space-between"><div>Hard</div><div id="hsHard">‚Äî</div></div>
    </div>
  </div>
  </div>

<script>
// ======================= Utilities =======================
const range = (n) => [...Array(n).keys()];
const clone = (grid) => grid.map(row => row.map(c => ({...c, notes:new Set(c.notes)})));
const emptyGrid = () => range(9).map(()=>range(9).map(()=>({value:0,given:false,notes:new Set(),conflict:false})));

function isSafe(vals,r,c,v){
  for(let i=0;i<9;i++){ if(vals[r][i]===v || vals[i][c]===v) return false; }
  const br=Math.floor(r/3)*3, bc=Math.floor(c/3)*3;
  for(let i=0;i<3;i++) for(let j=0;j<3;j++){ if(vals[br+i][bc+j]===v) return false; }
  return true;
}
function shuffled(a){ a=[...a]; for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]];} return a; }
function solve(vals){
  for(let r=0;r<9;r++) for(let c=0;c<9;c++) if(vals[r][c]===0){
    for(const v of shuffled([1,2,3,4,5,6,7,8,9])) if(isSafe(vals,r,c,v)){ vals[r][c]=v; if(solve(vals)) return true; vals[r][c]=0; }
    return false;
  }
  return true;
}
function countSolutions(vals,limit=2){ let count=0; (function bt(){
  for(let r=0;r<9;r++) for(let c=0;c<9;c++) if(vals[r][c]===0){
    for(let v=1;v<=9;v++) if(isSafe(vals,r,c,v)){ vals[r][c]=v; bt(); if(count>=limit) return; vals[r][c]=0; }
    return; }
  count++; })(); return Math.min(count,limit); }
function generateSolvedBoard(){ const v=range(9).map(()=>range(9).map(()=>0));
  const first=shuffled([1,2,3,4,5,6,7,8,9]); for(let c=0;c<9;c++) v[0][c]=first[c]; solve(v); return v; }
function makePuzzleFromSolution(solution,difficulty){
  const vals=solution.map(r=>r.slice()); const targets={easy:[40,45],medium:[32,36],hard:[26,30]};
  const [minCl,maxCl]=targets[difficulty]||targets.medium; const target=Math.floor((minCl+maxCl)/2);
  const order=shuffled(range(81)); let clues=81; for(const idx of order){ if(clues<=target) break; const r=Math.floor(idx/9), c=idx%9; const prev=vals[r][c]; if(prev===0) continue; vals[r][c]=0; const copy=vals.map(row=>row.slice()); const sol=countSolutions(copy,2); if(sol!==1) vals[r][c]=prev; else clues--; }
  return vals.map(row=>row.map(v=>({value:v,given:v!==0,notes:new Set(),conflict:false})));
}
function toValues(grid){ return grid.map(row=>row.map(c=>c.value||0)); }
function computeConflicts(grid){
  const vals=toValues(grid); const bad=new Set();
  for(let r=0;r<9;r++){ const seen=new Map(); for(let c=0;c<9;c++){ const v=vals[r][c]; if(!v) continue; const k=`r${r}#${v}`; if(seen.has(k)){ bad.add(`${r},${c}`); bad.add(`${r},${seen.get(k)}`); } else seen.set(k,c);} }
  for(let c=0;c<9;c++){ const seen=new Map(); for(let r=0;r<9;r++){ const v=vals[r][c]; if(!v) continue; const k=`c${c}#${v}`; if(seen.has(k)){ bad.add(`${r},${c}`); bad.add(`${seen.get(k)},${c}`);} else seen.set(k,r);} }
  for(let br=0;br<3;br++) for(let bc=0;bc<3;bc++){ const seen=new Map(); for(let i=0;i<3;i++) for(let j=0;j<3;j++){ const r=br*3+i, c=bc*3+j, v=vals[r][c]; if(!v) continue; const k=`b${br}${bc}#${v}`; if(seen.has(k)){ bad.add(`${r},${c}`); const p=seen.get(k); bad.add(`${p.r},${p.c}`);} else seen.set(k,{r,c}); }}
  return grid.map((row,r)=>row.map((cell,c)=>({...cell, conflict:bad.has(`${r},${c}`)})));
}
function findEmpty(grid){ for(let r=0;r<9;r++) for(let c=0;c<9;c++) if(grid[r][c].value===0) return {r,c}; return null; }
function solveFromGrid(grid){ const vals=toValues(grid); const s=vals.map(r=>r.slice()); return solve(s)?s:null; }

// ======================= State =======================
const state={
  paused:false,
  dirty:false,
  difficulty:'medium', grid:emptyGrid(), solution:null, selected:{r:0,c:0}, notesMode:false, mistakes:0, seconds:0, timer:null, activeDigit:0, bestSeconds:null,
  darkMode:false,
};

// Best time helpers (prefer localStorage; fallback to sessionStorage)
const bestKey = (d)=>`sudoku_best_${d}`;
function loadBest(d){
  try{
    const k=bestKey(d);
    let v=null;
    try{ v=localStorage.getItem(k); }catch(e){}
    if(v!=null) return parseInt(v,10);
    try{ v=sessionStorage.getItem(k); }catch(e){}
    return v!=null ? parseInt(v,10) : null;
  }catch(e){ return null; }
}
function saveBest(d,sec){
  const k=bestKey(d);
  try{ localStorage.setItem(k, String(sec)); }
  catch(e){ try{ sessionStorage.setItem(k, String(sec)); }catch(e2){} }
}

// ======================= DOM helpers =======================
const elBoard = document.getElementById('board');
const elBoardShell = document.getElementById('boardShell');
const elMistakes = document.getElementById('mistakes');
const elTimer = document.getElementById('timer');
const elTimerPill = document.getElementById('timerPill');
const elDiffPill = document.getElementById('difficultyPill');
const elDiffSelectInModal = document.getElementById('ngDifficulty');
const elDiffLabel = document.getElementById('difficultyLabel');
const elWin = document.getElementById('win');
const elFinalTime = document.getElementById('finalTime');
const elFinalMistakes = document.getElementById('finalMistakes');
const padWrap = document.querySelector('.pad');

const confettiCanvas = document.getElementById('confetti');
const cctx = confettiCanvas.getContext('2d');
const pauseOverlay = document.getElementById('pauseOverlay');

// New Game modal elements
const ngBackdrop = document.getElementById('ngBackdrop');
const ngModal = document.getElementById('ngModal');
const ngClose = document.getElementById('ngClose');
const ngCancel = document.getElementById('ngCancel');
const ngStart = document.getElementById('ngStart');

// High Scores modal elements
const hsBackdrop = document.getElementById('hsBackdrop');
const hsModal = document.getElementById('hsModal');
const hsClose = document.getElementById('hsClose');

// Theme toggle elements
const themeToggle = document.getElementById('themeToggle');
const themeIcon = document.getElementById('themeIcon');

function prettyTime(sec){ const m=String(Math.floor(sec/60)).padStart(2,'0'); const s=String(sec%60).padStart(2,'0'); return `${m}:${s}`; }
function prettyOrDash(sec){ return sec==null ? '‚Äî' : prettyTime(sec); }

// Theme management
function loadTheme(){
  try{
    const saved = localStorage.getItem('sudoku_theme');
    if(saved === 'dark') state.darkMode = true;
  }catch(e){}
  applyTheme();
}
function saveTheme(){
  try{
    localStorage.setItem('sudoku_theme', state.darkMode ? 'dark' : 'light');
  }catch(e){}
}
function applyTheme(){
  document.documentElement.setAttribute('data-theme', state.darkMode ? 'dark' : 'light');
  themeIcon.textContent = state.darkMode ? '‚òÄÔ∏è' : 'üåô';
}
function toggleTheme(){
  state.darkMode = !state.darkMode;
  applyTheme();
  saveTheme();
}

// Query param helpers for difficulty
function getUrlDifficulty(){
  try{
    const p=new URLSearchParams(window.location.search);
    const d=p.get('difficulty');
    return ['easy','medium','hard'].includes(d)?d:null;
  }catch(e){ return null; }
}
function setUrlDifficulty(d){
  try{
    const p=new URLSearchParams(window.location.search);
    p.set('difficulty', d);
    const url = window.location.pathname + '?' + p.toString() + window.location.hash;
    history.replaceState(null, '', url);
  }catch(e){}
}

function startTimer(){
  if(state.timer) clearInterval(state.timer);
  if(state.paused) return; // don't tick when paused
  elTimer.textContent=prettyTime(state.seconds);
  state.timer=setInterval(()=>{ state.seconds++; elTimer.textContent=prettyTime(state.seconds); },1000);
}

// ======================= Confetti =======================
function launchConfetti(duration=2500){
  const W = confettiCanvas.width = window.innerWidth;
  const H = confettiCanvas.height = window.innerHeight;
  const colors = ['#f59e0b','#10b981','#3b82f6','#ef4444','#a855f7','#f97316'];
  const N = 180;
  const parts = Array.from({length:N},()=>({
    x: Math.random()*W,
    y: -Math.random()*H,
    vx: (Math.random()-0.5)*2,
    vy: 2 + Math.random()*3,
    size: 4 + Math.random()*6,
    rot: Math.random()*Math.PI*2,
    vr: (Math.random()-0.5)*0.2,
    color: colors[(Math.random()*colors.length)|0]
  }));
  let raf, start;
  confettiCanvas.classList.add('show');
  function step(t){
    if(!start) start=t; const dt=t-start; cctx.clearRect(0,0,W,H);
    parts.forEach(p=>{ p.x+=p.vx; p.y+=p.vy; p.rot+=p.vr; if(p.y>H){p.y=-10; p.x=Math.random()*W;} cctx.save(); cctx.translate(p.x,p.y); cctx.rotate(p.rot); cctx.fillStyle=p.color; cctx.fillRect(-p.size/2,-p.size/2,p.size,p.size); cctx.restore(); });
    if(dt < duration) raf=requestAnimationFrame(step); else { confettiCanvas.classList.remove('show'); cancelAnimationFrame(raf); }
  }
  raf=requestAnimationFrame(step);
}

// ======================= Rendering =======================
function renderBoard(){
  elBoard.innerHTML='';
  for(let r=0;r<9;r++){
    for(let c=0;c<9;c++){
      const cell=state.grid[r][c];
      const d=document.createElement('div'); d.className='cell';
      if(cell.given) d.classList.add('given'); else d.classList.add('input');
      const isSel=state.selected.r===r && state.selected.c===c;
      if(isSel) d.classList.add('sel');
      const isWrong = !cell.given && cell.value!==0 && state.solution && cell.value !== state.solution[r][c];
      if(isWrong) d.classList.add('wrong');
      const sameAsSelected = state.activeDigit!==0 && cell.value===state.activeDigit;
      if(sameAsSelected && !isSel) d.classList.add('match');
      if(cell.conflict) d.classList.add('conflict');

      // borders for boxes
      const thickRight=((c+1)%3===0 && c!==8), thickBottom=((r+1)%3===0 && r!==8);
      if(thickRight) d.style.borderRight=`var(--box-thick) solid #cbd5e1`;
      if(thickBottom) d.style.borderBottom=`var(--box-thick) solid #cbd5e1`;

      d.tabIndex=0; d.setAttribute('role','button'); d.setAttribute('aria-label',`r${r+1} c${c+1}`);
      d.addEventListener('click',()=>{ if(state.paused) return; state.selected={r,c}; state.activeDigit=state.grid[r][c].value||0; renderBoard(); });

      if(cell.value!==0){ d.textContent=cell.value; }
      else{
        const notes=document.createElement('div'); notes.className='notes';
        for(let n=1;n<=9;n++){ const s=document.createElement('div'); s.className='note'; s.textContent=cell.notes.has(n)?n:''; notes.appendChild(s);}
        d.appendChild(notes);
      }
      elBoard.appendChild(d);
    }
  }
}

function remainingCounts(){
  const counts = Array(10).fill(0); // 0..9
  for(let r=0;r<9;r++) for(let c=0;c<9;c++){
    const v = state.grid[r][c].value;
    if(v>=1 && v<=9) counts[v]++;
  }
  const remaining = {};
  for(let n=1;n<=9;n++) remaining[n] = 9 - counts[n];
  return remaining;
}

function renderPad(){
  const rem = remainingCounts();
  padWrap.innerHTML='';
  for(let n=1;n<=9;n++){
    const b=document.createElement('button'); b.className='btn num'; b.title = state.notesMode?`Toggle note ${n}`:`Place ${n}`;
    b.innerHTML = `<div>${n}</div><div class="sub">${rem[n]}</div>`;
    if(rem[n]===0) b.disabled = true;
    b.addEventListener('click',()=>handleInput(n));
    padWrap.appendChild(b);
  }
  const er=document.createElement('button'); er.className='btn num'; er.innerHTML='<div>Erase</div><div class="sub">&nbsp;</div>'; er.addEventListener('click',()=>handleInput(0));
  padWrap.appendChild(er);
}

function updateHeader(){
  elMistakes.textContent=state.mistakes;
  elDiffLabel.textContent=state.difficulty;
  const elBestPill = document.getElementById('bestPill');
  if(elBestPill){ elBestPill.textContent = state.bestSeconds==null ? '‚Äî' : prettyTime(state.bestSeconds); }
}

// ======================= Game logic wrappers =======================
function newGame(level=state.difficulty){
  state.difficulty=level; updateHeader();
  const solved=generateSolvedBoard();
  const puzzle=makePuzzleFromSolution(solved, level);
  state.solution=solved; state.grid=computeConflicts(puzzle);
  state.mistakes=0; state.selected={r:0,c:0}; state.activeDigit=0;
  state.paused=false; pauseOverlay.classList.remove('show'); elBoardShell.classList.remove('hide'); padWrap.classList.remove('hide');
  clearInterval(state.timer); state.seconds=0; startTimer(); renderBoard(); renderPad(); elWin.classList.add('hide');
  state.bestSeconds = loadBest(state.difficulty);
  state.dirty=false;
  updateHeader();
  setUrlDifficulty(state.difficulty);
}

function handleInput(n){ if(state.paused) return;
  const {r,c}=state.selected; const g=clone(state.grid); const cell=g[r][c];
  if(cell.given) return;
  // Don't allow reentry for a box after you already got it right
  if(!state.notesMode && n!==0 && state.solution && cell.value === state.solution[r][c]) return;
  if(state.notesMode){ if(n===0) cell.notes.clear(); else if(cell.notes.has(n)) cell.notes.delete(n); else cell.notes.add(n); }
  else {
    cell.value=n; cell.notes.clear();
    if(state.solution && n!==0){
      if(n!==state.solution[r][c]) state.mistakes++; else {
        // Correct entry: remove n from notes in same row/col/box
        for(let cc=0; cc<9; cc++){ if(cc!==c) g[r][cc].notes.delete(n); }
        for(let rr=0; rr<9; rr++){ if(rr!==r) g[rr][c].notes.delete(n); }
        const br=Math.floor(r/3)*3, bc=Math.floor(c/3)*3;
        for(let i=0;i<3;i++) for(let j=0;j<3;j++){
          const rr=br+i, cc=bc+j; if(rr===r && cc===c) continue; g[rr][cc].notes.delete(n);
        }
      }
    }
  }
  state.dirty=true;
  state.grid=computeConflicts(g); state.activeDigit=state.grid[r][c].value||0; updateHeader(); renderBoard(); renderPad(); checkWin();
}

function giveHint(){ if(state.paused) return; if(!state.solution) return; const empty=findEmpty(state.grid); if(!empty) return; const {r,c}=empty; const g=clone(state.grid); g[r][c].value=state.solution[r][c]; g[r][c].notes.clear(); state.dirty=true; state.grid=computeConflicts(g); renderBoard(); renderPad(); checkWin(); }

function autoNotes(){ if(state.paused) return; const g=clone(state.grid); const vals=toValues(g); for(let r=0;r<9;r++) for(let c=0;c<9;c++){ const cell=g[r][c]; if(cell.value!==0){ cell.notes.clear(); continue;} const s=new Set(); for(let v=1;v<=9;v++) if(isSafe(vals,r,c,v)) s.add(v); cell.notes=s;} state.dirty=true; state.grid=computeConflicts(g); renderBoard(); /* counts unchanged */ }

function validateAndSolve(){ if(state.paused) return; const solved=solveFromGrid(state.grid); if(!solved){ alert('This grid has no solution (based on current entries).\nTry undoing some moves.'); return; }
  const g=clone(state.grid); for(let r=0;r<9;r++) for(let c=0;c<9;c++){ g[r][c].value=solved[r][c]; g[r][c].notes.clear(); } state.dirty=true; state.grid=computeConflicts(g); renderBoard(); renderPad(); checkWin(); }

function checkWinCondition(){ if(!state.solution) return false; for(let r=0;r<9;r++) for(let c=0;c<9;c++) if(state.grid[r][c].value!==state.solution[r][c]) return false; return true; }
function checkWin(){ if(!state.solution) return; for(let r=0;r<9;r++) for(let c=0;c<9;c++) if(state.grid[r][c].value!==state.solution[r][c]) return; // not yet
  clearInterval(state.timer); elFinalTime.textContent=prettyTime(state.seconds); elFinalMistakes.textContent=state.mistakes; elWin.classList.remove('hide');
  // Update best time
  if(state.bestSeconds==null || state.seconds < state.bestSeconds){ state.bestSeconds = state.seconds; saveBest(state.difficulty, state.bestSeconds); }
  const elBestPill = document.getElementById('bestPill');
  const elBestTime = document.getElementById('bestTime');
  if(elBestPill) elBestPill.textContent = prettyTime(state.bestSeconds);
  if(elBestTime) elBestTime.textContent = prettyTime(state.bestSeconds);
  launchConfetti();
  // Solved: no need to warn about navigation
  state.dirty=false;
}

// ======================= Events =======================
renderPad();

// Notes toggle
document.getElementById('notesToggle').addEventListener('click',()=>{ state.notesMode=!state.notesMode; document.getElementById('notesToggle').textContent = `Notes Mode (${state.notesMode?'On':'Off'}) ‚ñß`; });

// Other controls
document.getElementById('hint').addEventListener('click',giveHint);
document.getElementById('solve').addEventListener('click',validateAndSolve);

// keyboard
window.addEventListener('keydown',(e)=>{
  if(e.key>='1' && e.key<='9') handleInput(parseInt(e.key,10));
  if(['0','Backspace','Delete'].includes(e.key)) handleInput(0);
  if(e.key==='n' || e.key==='N'){ state.notesMode=!state.notesMode; document.getElementById('notesToggle').textContent = `Notes Mode (${state.notesMode?'On':'Off'}) ‚ñß`; }
  if(e.key==='ArrowUp'){ state.selected={r:(state.selected.r+8)%9,c:state.selected.c}; renderBoard(); }
  if(e.key==='ArrowDown'){ state.selected={r:(state.selected.r+1)%9,c:state.selected.c}; renderBoard(); }
  if(e.key==='ArrowLeft'){ state.selected={r:state.selected.r,c:(state.selected.c+8)%9}; renderBoard(); }
  if(e.key==='ArrowRight'){ state.selected={r:state.selected.r,c:(state.selected.c+1)%9}; renderBoard(); }
});

// Pause toggle via timer pill + overlay
function pauseGame(){ if(state.paused) return;
  // Don't allow pausing after you finish
  if(state.solution && checkWinCondition()) return;
  state.paused=true; clearInterval(state.timer); pauseOverlay.classList.add('show'); elBoardShell.classList.add('hide'); padWrap.classList.add('hide'); }
function resumeGame(){ if(!state.paused) return; state.paused=false; pauseOverlay.classList.remove('show'); elBoardShell.classList.remove('hide'); padWrap.classList.remove('hide'); startTimer(); }
function togglePause(){ state.paused ? resumeGame() : pauseGame(); }
document.getElementById('timerPill').addEventListener('click', togglePause);
pauseOverlay.addEventListener('click', resumeGame);

// New Game modal open (tap difficulty pill)
elDiffPill.addEventListener('click', ()=>{
  // preset select to current difficulty
  elDiffSelectInModal.value = state.difficulty;
  ngBackdrop.classList.add('show');
  ngModal.classList.add('show');
});
// New Game modal close
function closeNg(){ ngBackdrop.classList.remove('show'); ngModal.classList.remove('show'); }
ngClose.addEventListener('click', closeNg);
ngCancel.addEventListener('click', closeNg);
ngBackdrop.addEventListener('click', closeNg);
// New Game modal start
ngStart.addEventListener('click', ()=>{
  const level = elDiffSelectInModal.value;
  newGame(level);
  closeNg();
});

// boot: prefer difficulty from URL, fallback to easy
const bootDifficulty = getUrlDifficulty() || 'easy';
loadTheme(); // Initialize theme before starting game
newGame(bootDifficulty);

// High Scores modal
function renderHighScores(){
  const e = document.getElementById('hsEasy');
  const m = document.getElementById('hsMedium');
  const h = document.getElementById('hsHard');
  if(e) e.textContent = prettyOrDash(loadBest('easy'));
  if(m) m.textContent = prettyOrDash(loadBest('medium'));
  if(h) h.textContent = prettyOrDash(loadBest('hard'));
}
function openHighScores(){ renderHighScores(); hsBackdrop.classList.add('show'); hsModal.classList.add('show'); }
function closeHighScores(){ hsBackdrop.classList.remove('show'); hsModal.classList.remove('show'); }
document.getElementById('bestPillBtn').addEventListener('click', openHighScores);
hsClose.addEventListener('click', closeHighScores);
hsBackdrop.addEventListener('click', closeHighScores);

// Theme toggle
themeToggle.addEventListener('click', toggleTheme);

// Warn on navigation if there is unsaved progress (user input)
window.addEventListener('beforeunload', (e)=>{
  if(!state.dirty) return;
  e.preventDefault();
  e.returnValue='';
});
</script>
</body>
</html>
